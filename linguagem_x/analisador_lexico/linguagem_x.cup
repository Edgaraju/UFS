/**
 * Especificação do analisador sintático para a Linguaguem X
 * java -jar ../utilitarios/java-cup-11a.jar -interface -parser AnalisadorSintatico -symbols iSimbolo linguagem_x.cup
 */
package analisador_lexico;

import java_cup.runtime.*;

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

// Palavras-chave
terminal VAR;
terminal CONS;
terminal BOOLEAN;
terminal INT;
terminal REAL;
terminal IF, THEN, ELSE;
terminal WHILE;
terminal PROCEDURE;
terminal FUNCTION;

terminal LBRACK, RBRACK;
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN;
terminal PLUS, MINUS, NOT, DIV, MOD;
terminal LT, GT; // relational_expression
terminal EQEQ;
terminal AND; // and_expression
terminal OR;  // inclusive_or_expression

// Terminais Literais
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER; // nome

// 19.2) The Syntactic Grammar
non terminal goal;
// 19.3) Lexical Structure
non terminal literal;
// 19.4) Types, Values, and Variables
non terminal type, primitive_type, numeric_type;
non terminal integral_type, floating_point_type;
non terminal reference_type;
non terminal array_type;
// 19.5) Names
non terminal name, simple_name;
// 19.6) Packages
non terminal compilation_unit;
non terminal type_declarations_opt, type_declarations;
non terminal type_declaration;
// 19.8.2) Field Declarations
non terminal variable_declarators, variable_declarator;
non terminal variable_declarator_id, variable_initializer;
// 19.8.3) Method Declarations
non terminal method_declaration, method_header, method_declarator;
non terminal formal_parameter_list_opt, formal_parameter_list;
non terminal formal_parameter;
non terminal method_body;
// 19.8.4) Procedure Declarations
non terminal procedure_declaration, procedure_header, procedure_declarator;
non terminal ref_parameter_list_opt, ref_parameter_list;
non terminal ref_parameter;
non terminal procedure_body;
// 19.10) Arrays
non terminal array_initializer;
non terminal variable_initializers;
// 19.11) Blocks and Statements
non terminal block;
non terminal block_statements_opt, block_statements, block_statement;
non terminal local_variable_declaration_statement, local_variable_declaration;
non terminal statement, statement_no_short_if;
non terminal statement_without_trailing_substatement;
non terminal empty_statement;
non terminal expression_statement, statement_expression;
non terminal if_then_statement;
non terminal if_then_else_statement, if_then_else_statement_no_short_if;
non terminal while_statement, while_statement_no_short_if;
// 19.12) Expressions
non terminal primary, primary_no_new_array;
non terminal argument_list_opt, argument_list;
non terminal array_creation_expression;
non terminal dim_exprs, dim_expr, dims_opt, dims;
non terminal method_invocation, array_access;
non terminal postfix_expression;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal cast_expression;
non terminal multiplicative_expression, additive_expression;
non terminal relational_expression, equality_expression;
non terminal and_expression, inclusive_or_expression;
non terminal conditional_expression, assignment_expression;
non terminal assignment;
non terminal left_hand_side;
non terminal expression;


start with goal;

// 19.2) The Syntactic Grammar
goal ::=    compilation_unit
    ;

// 19.3) Lexical Structure.
literal ::= INTEGER_LITERAL
    |   FLOATING_POINT_LITERAL
    |   BOOLEAN_LITERAL
    |   CHARACTER_LITERAL
    |   STRING_LITERAL
    ;

// 19.4) Types, Values, and Variables
type    ::= primitive_type
    |   reference_type
    ;
primitive_type ::=
        numeric_type
    |   BOOLEAN
    ;
numeric_type::= integral_type
    |   floating_point_type
    ;
integral_type ::= 
        INT 
    ;
floating_point_type ::= 
        REAL 
    ;

reference_type ::=
        array_type
    ;

array_type ::=  primitive_type dims
    |   name dims
    ;

// 19.5) Names
name    ::= simple_name
    ;
simple_name ::= IDENTIFIER
    ;

// 19.6) Packages
compilation_unit ::=
        type_declarations_opt
        ;
type_declarations_opt   ::= type_declarations   | ;
type_declarations ::= 
        type_declaration
    |   type_declarations type_declaration
    ;
type_declaration ::=
        variable_declarators
    |   method_declaration // FUNCAO
    |   procedure_declaration // PROCEDIMENTO
    |   SEMICOLON
    ;

// 19.8.2) Field Declarations
variable_declarators ::=
        variable_declarator
    |   variable_declarators COMMA variable_declarator
    ;
variable_declarator ::=
        variable_declarator_id
    |   variable_declarator_id EQ variable_initializer
    ;
variable_declarator_id ::=
        IDENTIFIER
    |   variable_declarator_id LBRACK RBRACK
    ;
variable_initializer ::=
        expression
    |   array_initializer
    ;

// 19.8.3) Method Declarations
method_declaration ::=
        FUNCTION method_header method_body
    ;
method_header ::=
        type method_declarator
    ;
method_declarator ::=
        IDENTIFIER LPAREN formal_parameter_list_opt RPAREN
    ;
formal_parameter_list_opt ::=
    |   formal_parameter_list
    ;
formal_parameter_list ::=
        formal_parameter
    |   formal_parameter_list COMMA formal_parameter
    ;
formal_parameter ::=
        VAR type variable_declarator_id
    |   CONS type variable_declarator_id
    ;
method_body ::= block
    |   SEMICOLON
    ;

// 19.8.4) Procedure Declarations
procedure_declaration ::=
        PROCEDURE procedure_header procedure_body
    ;
procedure_header ::=
        procedure_declarator
    ;
procedure_declarator ::=
        IDENTIFIER LPAREN ref_parameter_list_opt RPAREN
    ;
ref_parameter_list_opt ::=
    |   ref_parameter_list
    ;
ref_parameter_list ::=
        ref_parameter
    |   ref_parameter_list COMMA ref_parameter
    ;
ref_parameter ::=
        type variable_declarator_id
    ;
procedure_body ::= block
    |   SEMICOLON
    ;

// 19.10) Arrays
array_initializer ::=
        LBRACE variable_initializers COMMA RBRACE
    |   LBRACE variable_initializers RBRACE
    |   LBRACE COMMA RBRACE
    |   LBRACE RBRACE
    ;
variable_initializers ::=
        variable_initializer
    |   variable_initializers COMMA variable_initializer
    ;

// 19.11) Blocks and Statements
block ::=   LBRACE block_statements_opt RBRACE
    ;
block_statements_opt ::=
    |   block_statements
    ;
block_statements ::=
        block_statement
    |   block_statements block_statement
    ;
block_statement ::=
        local_variable_declaration_statement
    |   statement
    ;
local_variable_declaration_statement ::=
        local_variable_declaration SEMICOLON
    ;
local_variable_declaration ::=
        VAR type variable_declarators
    |   CONS type variable_declarators
    ;
statement ::=   statement_without_trailing_substatement
    |   if_then_statement
    |   if_then_else_statement
    |   while_statement
    ;
statement_no_short_if ::=
        statement_without_trailing_substatement
    |   if_then_else_statement_no_short_if
    |   while_statement_no_short_if
    ;
statement_without_trailing_substatement ::=
        block
    |   empty_statement
    |   expression_statement
    ;
empty_statement ::=
        SEMICOLON
    ;
expression_statement ::=
        statement_expression SEMICOLON
    ;
statement_expression ::=
        assignment
    |   method_invocation
    ;
if_then_statement ::=
        IF LPAREN expression RPAREN THEN statement
    ;
if_then_else_statement ::=
        IF LPAREN expression RPAREN THEN statement_no_short_if 
            ELSE statement
    ;
if_then_else_statement_no_short_if ::=
        IF LPAREN expression RPAREN THEN statement_no_short_if
            ELSE statement_no_short_if
    ;
while_statement ::=
        WHILE LPAREN expression RPAREN statement
    ;
while_statement_no_short_if ::=
        WHILE LPAREN expression RPAREN statement_no_short_if
    ;


// 19.12) Expressions
primary ::= primary_no_new_array
    |   array_creation_expression
    ;
primary_no_new_array ::=
        literal
    |   LPAREN expression RPAREN
    |   method_invocation
    |   array_access
    ;

argument_list_opt ::=
    |   argument_list
    ;
argument_list ::=
        expression
    |   argument_list COMMA expression
    ;
array_creation_expression ::=
        VAR name primitive_type dim_exprs dims_opt
    |   CONS name primitive_type dim_exprs dims_opt
    |   VAR name primitive_type dims array_initializer
    |   CONS name primitive_type dims array_initializer
    ;
dim_exprs ::=   dim_expr
    |   dim_exprs dim_expr
    ;
dim_expr ::=    LBRACK expression RBRACK
    ;
dims_opt ::=
    |   dims
    ;
dims ::=    LBRACK RBRACK
    |   dims LBRACK RBRACK
    ;
method_invocation ::=
        name LPAREN argument_list_opt RPAREN
    ;
array_access ::=
        name LBRACK expression RBRACK
    |   primary_no_new_array LBRACK expression RBRACK
    ;
postfix_expression ::=
        primary
    |   name
    ;
unary_expression ::=
        MINUS unary_expression
    |   unary_expression_not_plus_minus
    ;

unary_expression_not_plus_minus ::=
        postfix_expression
    |   NOT unary_expression
    |   cast_expression
    ;
cast_expression ::=
        LPAREN primitive_type dims_opt RPAREN unary_expression
    |   LPAREN expression RPAREN unary_expression_not_plus_minus
    |   LPAREN name dims RPAREN unary_expression_not_plus_minus
    ;
multiplicative_expression ::=
        unary_expression
    |   multiplicative_expression MULT unary_expression
    |   multiplicative_expression DIV unary_expression
    |   multiplicative_expression MOD unary_expression
    ;
additive_expression ::=
        multiplicative_expression
    |   additive_expression PLUS multiplicative_expression
    |   additive_expression MINUS multiplicative_expression
    ;
relational_expression ::=
        additive_expression
    |   relational_expression LT additive_expression
    |   relational_expression GT additive_expression
    ;
equality_expression ::=
        relational_expression
    |   equality_expression EQEQ relational_expression
    ;
and_expression ::=
        equality_expression
    |   and_expression AND equality_expression
    ;
inclusive_or_expression ::=
        and_expression
    |   inclusive_or_expression OR and_expression
    ;
conditional_expression ::=
        inclusive_or_expression
    ;
assignment_expression ::=
        conditional_expression
    |   assignment
    ;
assignment ::=  left_hand_side EQ assignment_expression
    ;
left_hand_side ::=
        name
    |   array_access
    ;
expression ::=  assignment_expression
    ;